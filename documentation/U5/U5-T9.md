# Unidad 5: Automatizaci√≥n y Producci√≥n
 
## Tema 9: Monitoreo y Logging

> [Back to Menu](../../README.md)

Imagina que tienes una aplicaci√≥n en producci√≥n y, de repente, un usuario reporta que no puede acceder a ciertas funcionalidades. ¬øC√≥mo identificas el problema? ¬øC√≥mo sabes si la aplicaci√≥n est√° funcionando correctamente o si est√° consumiendo demasiados recursos? Aqu√≠ es donde entran en juego dos conceptos fundamentales en la administraci√≥n y operaci√≥n de software: Monitoreo y Logging.

En el desarrollo de software, especialmente en entornos productivos, no basta con escribir c√≥digo funcional. Es fundamental asegurarse de que la aplicaci√≥n opera de manera eficiente, detectar errores antes de que afecten a los usuarios y optimizar el rendimiento con base en datos reales. El monitoreo y el logging son herramientas esenciales para lograrlo.

A lo largo de la historia de .NET, la implementaci√≥n de un buen sistema de logging ha transformado radicalmente la forma en que se desarrolla y mantiene el software. Durante los primeros d√≠as del .NET Framework, los desarrolladores a menudo confiaban en soluciones ad-hoc o en herramientas de terceros como log4net y NLog para capturar eventos cr√≠ticos. Estas herramientas, aunque √∫tiles, a menudo requer√≠an una configuraci√≥n compleja y no estaban integradas de forma nativa en el ecosistema de .NET.

Con la llegada de .NET Core y la posterior evoluci√≥n hacia .NET 5/6/7/8, Microsoft introdujo el paquete `Microsoft.Extensions.Logging`. Esta biblioteca no solo proporcion√≥ una API unificada y f√°cil de usar para el logging, sino que tambi√©n facilit√≥ la integraci√≥n con servicios modernos de monitoreo y an√°lisis, como Application Insights, ELK Stack y Prometheus. Gracias a esta integraci√≥n, las aplicaciones se volvieron m√°s observables y se pudo detectar y solucionar problemas de rendimiento o errores cr√≠ticos en entornos de producci√≥n de manera casi inmediata.

Entre los eventos que se han mejorado notablemente gracias al logging se encuentra la capacidad para rastrear transacciones en sistemas distribuidos, identificar cuellos de botella en arquitecturas de microservicios y detectar comportamientos an√≥malos que podr√≠an indicar problemas de seguridad o fallos en la infraestructura. Por ejemplo, en escenarios de alta concurrencia, un buen sistema de logging permite a los equipos de operaciones comprender mejor el flujo de las solicitudes, identificar r√°pidamente d√≥nde se produce la latencia y tomar acciones correctivas antes de que un error afecte a los usuarios finales. Adem√°s, la adopci√≥n de logging estructurado ha sido fundamental para la implementaci√≥n de estrategias de monitoreo centralizado, lo que ha permitido a las organizaciones mejorar la escalabilidad y resiliencia de sus sistemas.

La evoluci√≥n del logging en .NET ha sido un factor clave para aumentar la confiabilidad, seguridad y rendimiento de las aplicaciones modernas. Implementar un sistema de logging robusto no solo ayuda a depurar y resolver problemas m√°s r√°pido, sino que tambi√©n sienta las bases para pr√°cticas avanzadas de monitoreo y an√°lisis, fundamentales en la era de las aplicaciones distribuidas y la computaci√≥n en la nube. Para profundizar en este tema, se recomienda consultar la [documentaci√≥n oficial de Microsoft sobre Logging en .NET.](https://learn.microsoft.com/es-es/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0)

### ¬øQu√© es el Logging?

El logging es el proceso de registrar eventos o informaci√≥n relevante sobre el funcionamiento de una aplicaci√≥n. Estos registros pueden incluir errores, advertencias, informaci√≥n de uso y eventos cr√≠ticos que pueden ser √∫tiles para el diagn√≥stico y soluci√≥n de problemas.

#### Beneficios del Logging:

1. Facilita la depuraci√≥n: Permite a los desarrolladores encontrar y corregir errores r√°pidamente.

2. Registra eventos importantes: Como intentos de inicio de sesi√≥n, cambios en la base de datos o transacciones fallidas.

3. Proporciona trazabilidad: Es posible reconstruir el flujo de ejecuci√≥n de una aplicaci√≥n y entender c√≥mo se lleg√≥ a cierto estado.

4. Mejora la seguridad: Se pueden detectar intentos de acceso no autorizados o actividades sospechosas.

### ST1. Introducci√≥n a Logging y Monitoreo. Serilog: Primeros Pasos.

A la hora de implementar un sistema de logging robusto en .NET, existen varias herramientas y librer√≠as que han sido dise√±adas para facilitar el registro estructurado y el an√°lisis de eventos. A continuaci√≥n, se describen algunas de las m√°s populares, junto con sus caracter√≠sticas y ventajas, para que puedas elegir la que mejor se adapte a las necesidades de tu aplicaci√≥n.

1. Microsoft.Extensions.Logging

    Esta es la librer√≠a de logging incorporada en el framework de .NET, que ofrece una API unificada y extensible para registrar eventos.

    **Caracter√≠sticas:**

    - Proporciona soporte nativo en ASP.NET Core y .NET, lo que garantiza una integraci√≥n fluida con el resto del ecosistema.

    - Permite configurar m√∫ltiples proveedores de logs (sinks) para registrar informaci√≥n en la consola, archivos, bases de datos, entre otros.

    - Facilita el logging estructurado, lo que ayuda a capturar datos de forma organizada para su an√°lisis.

    **Ventajas:**

    - No requiere instalaciones adicionales, ya que viene incluido en el framework.

    - Es altamente configurable y extensible, permitiendo agregar proveedores personalizados seg√∫n las necesidades.

    Para m√°s informaci√≥n, consulta la [documentaci√≥n oficial de Microsoft.](https://learn.microsoft.com/es-es/aspnet/core/fundamentals/logging/?view=aspnetcore-9.0)

    **Ejemplo b√°sico de `Microsoft.Extensions.Logging`**

    En una API de .NET, se puede configurar logging f√°cilmente con ILogger:

    ```csharp
    using Microsoft.Extensions.Logging;

    public class EjemploService
    {
        private readonly ILogger<EjemploService> _logger;

        public EjemploService(ILogger<EjemploService> logger)
        {
            _logger = logger;
        }

        public void Procesar()
        {
            _logger.LogInformation("Iniciando procesamiento...");
            try
            {
                // L√≥gica de negocio
                _logger.LogDebug("Ejecutando paso 1 del proceso.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ocurri√≥ un error en el procesamiento.");
            }
        }
    }
    ```

2. Serilog

    Serilog es una de las librer√≠as de logging m√°s modernas y populares en el ecosistema .NET, conocida por su capacidad para realizar logging estructurado.

    **Caracter√≠sticas:**

    - Permite registrar eventos en formatos estructurados (por ejemplo, JSON), facilitando el an√°lisis y la integraci√≥n con sistemas de monitoreo y an√°lisis como Elasticsearch o Splunk.
    
    - Es altamente configurable mediante la definici√≥n de sinks, que son destinos donde se env√≠an los logs (archivo, consola, bases de datos, etc.).
    
    - Se integra f√°cilmente con ASP.NET Core y soporta una amplia gama de formatos y filtros.
    
    **Ventajas:**
    - Proporciona logs ricos en informaci√≥n, lo que es esencial para diagnosticar problemas en aplicaciones complejas.
    
    - Su enfoque estructurado mejora la capacidad de b√∫squeda y an√°lisis de logs en sistemas centralizados.
    
    Consulta la [documentaci√≥n de Serilog](https://serilog.net/) para conocer todas sus capacidades y configuraciones.

    **Ejemplo b√°sico de `Serilog`**

    Es necesario agregar los siguientes paquetes para configurar y trabajar con Serilog: `Serilog.AspNetCore`, `Serilog.Sinks.Console`

    Abre el archivo Program.cs y configura Serilog de la siguiente manera:

    ```csharp
    using Serilog;

    // Configurar Serilog. Esta configuraci√≥n debe ubicarse por encima de la definici√≥n de la app.
    Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .CreateLogger();
    builder.Host.UseSerilog();

    var app = builder.Build();
    ```

    Por √∫ltimo, la implementaci√≥n del `ILogger<T>` es exactamente igual a `Microsoft.Extensions.Logging`.

    Recuerda que `Microsoft.Extensions.Logging` te da una API estandarizada y desacoplada, mientras que `Serilog` te da poder y flexibilidad para registrar los logs en diferentes formatos y destinos.

3. NLog

    NLog es otra librer√≠a ampliamente utilizada en el entorno .NET, reconocida por su flexibilidad y alto rendimiento en la gesti√≥n de logs.

    **Caracter√≠sticas:**

    - Ofrece una gran variedad de targets o destinos para los logs, incluyendo archivos, bases de datos, la consola, y m√°s.
    
    - Permite configurar el formato de los logs de manera detallada, facilitando su lectura y an√°lisis.
    
    - Soporta la configuraci√≥n mediante archivos XML o mediante c√≥digo, lo que brinda flexibilidad en la gesti√≥n de la configuraci√≥n.
    
    **Ventajas:**

    - Es muy robusta y madura, con a√±os de uso en aplicaciones empresariales.
    
    - Permite el logging as√≠ncrono para no afectar el rendimiento de la aplicaci√≥n en entornos de alta carga.

    En primera instancia, para su implementaci√≥n necesitas 3 librer√≠as: `NLog`, `NLog.Web.AspNetCore`, `Microsoft.Extensions.Logging.Abstractions`.

    Luego, es necesario crear un archivo `nlog.config` en la raiz de tu proyecto:

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
        xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

        <!-- Configurar nivel de logging (Trace, Debug, Info, Warn, Error, Fatal) -->
        <targets>
            <target name="console" xsi:type="Console" layout="${longdate} | ${level:uppercase=true} | ${logger} | ${message} ${exception}" />
            <target name="file" xsi:type="File" fileName="logs/log.txt" layout="${longdate} | ${level} | ${message} ${exception}" />
        </targets>

        <rules>
            <logger name="*" minlevel="Info" writeTo="console,file" />
        </rules>

    </nlog>
    ```
    **Explicaci√≥n:**

    1. console: Muestra logs en la consola.
    2. file: Guarda los logs en un archivo dentro de la carpeta logs/.
    3. minlevel="Info": Registra logs desde nivel Info en adelante.

    A continuaci√≥n podr√°s ver la configuraci√≥n base de la librer√≠a en tu `Program.cs`

    ```csharp
    using Microsoft.AspNetCore.Builder;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Hosting;
    using NLog;
    using NLog.Web;

    //En esta instrucci√≥n usamos el archivo de configuraci√≥n creado en el paso anterior.
    var logger = LogManager.Setup().LoadConfigurationFromFile("nlog.config").GetCurrentClassLogger();

    try
    {
        logger.Info("Iniciando aplicaci√≥n...");

        var builder = WebApplication.CreateBuilder(args);

        // Reemplazar el sistema de logging de .NET con NLog
        builder.Logging.ClearProviders();
        builder.Host.UseNLog();

        var app = builder.Build();

        app.MapGet("/", () => "Hola, NLog en ASP.NET Core!");

        app.Run();
    }
    catch (Exception ex)
    {
        logger.Error(ex, "La aplicaci√≥n fall√≥ al iniciar");
        throw;
    }
    finally
    {
        LogManager.Shutdown();
    }
    
    ```
    **Explicaci√≥n:**

    * `LogManager.Setup().LoadConfigurationFromFile("nlog.config")`: Carga la configuraci√≥n de nlog.config.
    
    * `builder.Logging.ClearProviders()`: Elimina otros proveedores de logging (como el de .NET).
    
    * `builder.Host.UseNLog()`: Reemplaza el sistema de logging de .NET con NLog.
    
    * `logger.Info("Iniciando aplicaci√≥n...")`: Muestra un mensaje de informaci√≥n en los logs.
    
    Por √∫ltimo, la implementaci√≥n del `ILogger<T>` es exactamente igual a `Microsoft.Extensions.Logging`.
    
    Puedes explorar m√°s sobre NLog en su [sitio oficial.](https://nlog-project.org/)

4. log4net

    log4net es una de las bibliotecas de logging m√°s antiguas y establecidas para .NET.

    **Caracter√≠sticas:**
    
    - Proporciona un sistema de logging muy configurable, con m√∫ltiples opciones para definir c√≥mo y d√≥nde se registran los logs.
    
    - Es compatible con una amplia gama de destinos, como archivos, bases de datos y servicios remotos.
    
    - Utiliza un archivo de configuraci√≥n (por lo general XML) para definir sus par√°metros, lo que facilita su integraci√≥n en aplicaciones heredadas.
    
    **Ventajas:**
    
    - Ha sido ampliamente adoptada y probada en aplicaciones de larga duraci√≥n, lo que garantiza su fiabilidad.
    
    - Su integraci√≥n con aplicaciones legadas la hace una opci√≥n viable en entornos donde se requiere compatibilidad con versiones anteriores.
    
    En esta ocasi√≥n s√≥lo es necesario agregar la librer√≠a de `log4net` a tu proyecto .Net, luego, como en ocasiones anteriores es necesario crear un archivo `log4net.config` para definir partes del comportamiento del loggeo dentro del proyecto:

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <log4net>
    <!-- Configuraci√≥n de la consola -->
    <appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender">
        <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%date %-5level %logger - %message%newline" />
        </layout>
    </appender>

    <!-- Configuraci√≥n de logs en archivo -->
    <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
        <file value="logs/app.log" />
        <appendToFile value="true" />
        <rollingStyle value="Date" />
        <datePattern value="yyyy-MM-dd'.log'" />
        <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%date %-5level %logger - %message%newline" />
        </layout>
    </appender>

    <!-- Nivel de log (Debug, Info, Warn, Error, Fatal) -->
    <root>
        <level value="INFO" />
        <appender-ref ref="ConsoleAppender" />
        <appender-ref ref="RollingFileAppender" />
    </root>
    </log4net>
    ```
    **Explicaci√≥n:**

    * `ConsoleAppender`: Muestra los logs en la consola.
    
    * `RollingFileAppender`: Guarda los logs en un archivo dentro de la carpeta logs/.
    
    * `level="INFO"`: Registra logs desde el nivel INFO en adelante.

    Ahora debemos editar nuestro `Program.cs` para cargar la configuraci√≥n definida en el paso anterior:
    ```csharp
    using System.Reflection;
    using log4net;
    using log4net.Config;

    var logRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());
    XmlConfigurator.Configure(logRepository, new FileInfo("log4net.config"));

    var logger = LogManager.GetLogger(typeof(Program));

    try
    {
        logger.Info("Iniciando aplicaci√≥n...");

        var builder = WebApplication.CreateBuilder(args);

        // Configurar el sistema de logging de .NET con log4net
        builder.Logging.ClearProviders();
        builder.Logging.AddLog4Net();

        var app = builder.Build();

        app.MapGet("/", () => "Hola, log4net en ASP.NET Core!");

        app.Run();
    }
    catch (Exception ex)
    {
        logger.Error("La aplicaci√≥n fall√≥ al iniciar", ex);
        throw;
    }
    ```
    **Explicaci√≥n:**

    * `XmlConfigurator.Configure(logRepository, new FileInfo("log4net.config"))`: Carga la configuraci√≥n desde log4net.config.
    
    * `builder.Logging.ClearProviders()`: Elimina otros proveedores de logging de .NET.
    
    * `builder.Logging.AddLog4Net()`: Agrega log4net como proveedor de logs.
    
    * `logger.Info("Iniciando aplicaci√≥n...")`: Registra un mensaje de informaci√≥n en los logs.

    Por √∫ltimo, la implementaci√≥n del `ILogger<T>` es exactamente igual a `Microsoft.Extensions.Logging`.
    
    **Problemas que ha enfrentado log4net en los √∫ltimos a√±os**

    En el mundo del desarrollo de software, las herramientas evolucionan constantemente, y lo que alguna vez fue una soluci√≥n confiable puede enfrentar desaf√≠os con el tiempo. log4net, una de las bibliotecas m√°s populares para la gesti√≥n de logs en .NET, no es la excepci√≥n. Aunque sigue siendo una opci√≥n v√°lida para muchos proyectos, en los √∫ltimos a√±os ha enfrentado algunos inconvenientes que han llevado a los desarrolladores a considerar alternativas m√°s modernas.

    1. Problemas de Seguridad: Vulnerabilidades y Riesgos

        Uno de los principales problemas que ha enfrentado log4net es la aparici√≥n de vulnerabilidades de seguridad. Un ejemplo significativo ocurri√≥ con versiones anteriores a la 2.0.10, donde se detect√≥ un problema relacionado con la manipulaci√≥n de archivos XML en la configuraci√≥n de logs. Esta vulnerabilidad permit√≠a ataques de inyecci√≥n de entidades externas XML (XXE), lo que podr√≠a comprometer datos sensibles o incluso habilitar accesos no autorizados dentro de la aplicaci√≥n.

        Aunque se lanz√≥ un parche para solucionar este problema, este tipo de incidentes han generado preocupaciones sobre la rapidez y eficiencia en la respuesta del equipo de mantenimiento de la herramienta.

    2. Falta de Actualizaciones Frecuentes

        Si bien log4net fue un est√°ndar de facto durante muchos a√±os, en la actualidad no recibe actualizaciones con la misma frecuencia que otras bibliotecas de logging, como Serilog o NLog. Esto puede generar problemas de compatibilidad con versiones m√°s recientes de .NET y puede hacer que los desarrolladores deban buscar soluciones alternativas o mantener configuraciones heredadas.

        Por ejemplo, .NET ha evolucionado significativamente con la llegada de .NET Core y .NET 5+, y muchas herramientas han adaptado sus arquitecturas para aprovechar las nuevas caracter√≠sticas de la plataforma. Sin embargo, log4net no ha evolucionado al mismo ritmo, lo que hace que su integraci√≥n en proyectos modernos pueda ser menos √≥ptima.

    3. Menor Comunidad y Soporte
    
        En el ecosistema de c√≥digo abierto, una comunidad activa es crucial para garantizar que una herramienta siga siendo relevante. Con el tiempo, log4net ha perdido tracci√≥n en comparaci√≥n con otras bibliotecas de logging, lo que significa que hay menos recursos disponibles, menos contribuciones al proyecto y una menor cantidad de documentaci√≥n o ejemplos actualizados.

        Esto puede hacer que la resoluci√≥n de problemas sea m√°s complicada, ya que hay menos foros, art√≠culos y contribuciones en comparaci√≥n con alternativas m√°s recientes.

    ¬øDeber√≠a seguir usando log4net?

    A pesar de estos problemas, log4net sigue siendo una herramienta funcional y muchas aplicaciones que lo utilizan siguen operando sin inconvenientes. Sin embargo, si est√°s comenzando un proyecto nuevo o quieres asegurarte de contar con una herramienta con soporte a largo plazo, es recomendable considerar alternativas m√°s modernas como Serilog o NLog, que ofrecen mayor seguridad, mejor integraci√≥n con .NET moderno y una comunidad m√°s activa.

    En desarrollo de software, estar informado y elegir herramientas que se adapten a las necesidades del proyecto es clave para construir aplicaciones robustas y seguras. ¬°Sigue explorando y aprendiendo!

    Para m√°s detalles, revisa la [documentaci√≥n de log4net.](https://logging.apache.org/log4net/)

### ST2. OpenTelemetry para Telemetr√≠a y Tracing.

Ahora vamos a sumergirnos en el fascinante mundo de OpenTelemetry, una herramienta esencial para la telemetr√≠a y el tracing en el desarrollo de software moderno. Si eres nuevo en estos conceptos, no te preocupes; te guiar√© paso a paso para que comprendas su importancia y c√≥mo pueden mejorar tus habilidades en desarrollo y automatizaci√≥n.

#### ¬øQu√© es OpenTelemetry?

Imagina que tu aplicaci√≥n es una gran ciudad llena de actividades: personas movi√©ndose, veh√≠culos transitando y eventos ocurriendo en cada esquina. Ahora, piensa en OpenTelemetry como el sistema de c√°maras y sensores que monitorean todo lo que sucede en esa ciudad. Es una plataforma de c√≥digo abierto dise√±ada para recopilar datos de telemetr√≠a (como m√©tricas, logs y trazas) de tus aplicaciones, permiti√©ndote entender su comportamiento y rendimiento

#### ¬øPor qu√© es importante OpenTelemetry?

En el mundo actual, las aplicaciones son cada vez m√°s complejas y distribuidas. OpenTelemetry te ayuda a:

* Obtener visibilidad completa: Te permite ver c√≥mo interact√∫an los diferentes componentes de tu aplicaci√≥n, lo que facilita la identificaci√≥n de cuellos de botella y problemas de rendimiento.

* Depurar errores m√°s r√°pido: Al rastrear las solicitudes a trav√©s de tu aplicaci√≥n, puedes identificar r√°pidamente la causa ra√≠z de los errores.

* Optimizar el rendimiento: Al analizar las m√©tricas y los traces, puedes identificar √°reas de mejora y optimizar el rendimiento de tu aplicaci√≥n.

* Monitorear la salud de tu aplicaci√≥n: Te permite configurar alertas y paneles de control para monitorear la salud de tu aplicaci√≥n en tiempo real.

#### Conceptos clave de OpenTelemetry:

* Telemetr√≠a: Es el conjunto de datos que se recopilan de una aplicaci√≥n, incluyendo m√©tricas, logs y traces.

* M√©tricas: Son medidas num√©ricas que representan el rendimiento de una aplicaci√≥n, como el tiempo de respuesta, el uso de CPU y la memoria utilizada.

* Logs: Son registros de eventos que ocurren en una aplicaci√≥n, como errores, advertencias e informaci√≥n.

* Traces: Son registros de la trayectoria de una solicitud a trav√©s de una aplicaci√≥n, lo que permite ver c√≥mo interact√∫an los diferentes componentes.

* Spans: Un span representa una unidad de trabajo dentro de un trace. Por ejemplo, una llamada a una base de datos o una solicitud HTTP.

* Contexto de traza: Es un identificador √∫nico que se propaga a trav√©s de una aplicaci√≥n para rastrear una solicitud.

* Instrumentaci√≥n: Es el proceso de agregar c√≥digo a una aplicaci√≥n para recopilar datos de telemetr√≠a.

* Coleccionistas: Son componentes que recopilan y exportan datos de telemetr√≠a a un backend de observabilidad.

* Exportadores: Son componentes que env√≠an datos de telemetr√≠a a un backend de observabilidad.
Backend de observabilidad: Es un sistema que almacena y analiza datos de telemetr√≠a.

#### ST3. Integraci√≥n de Serilog y OpenTelemetry:

OpenTelemetry se integra perfectamente con .NET, lo que te permite instrumentar tus aplicaciones .NET con facilidad. .NET proporciona bibliotecas y herramientas que facilitan la recopilaci√≥n y exportaci√≥n de datos de telemetr√≠a.

##### ¬øC√≥mo empezar con OpenTelemetry en .NET?

* Agrega los paquetes NuGet de OpenTelemetry a tu proyecto.
    ```shell
    dotnet add package OpenTelemetry.Extensions.Hosting  
    dotnet add package OpenTelemetry.Instrumentation.AspNetCore  
    dotnet add package OpenTelemetry.Exporter.Console  
    # Agregamos Serilog para grabar los mensajes ya que ayuda con flexibilidad y soporte para logs estructurados 
    # ideal para sistemas como Elasticsearch o Seq.
    dotnet add package Serilog.AspNetCore  
    dotnet add package Serilog.Sinks.OpenTelemetry 
    ```

* Configura la instrumentaci√≥n para recopilar los datos de telemetr√≠a que necesitas en el `Program.cs`.

    ```csharp
    using OpenTelemetry.Logs;  
    using OpenTelemetry.Metrics;  
    using OpenTelemetry.Trace;  
    using Serilog;  

    var builder = WebApplication.CreateBuilder(args);  

    // Configura Serilog para enviar logs a OpenTelemetry  
    Log.Logger = new LoggerConfiguration()  
        .WriteTo.OpenTelemetry(options =>  
        {  
            options.Endpoint = "http://localhost:4317"; // Ejemplo para OTLP  
            options.Protocol = Serilog.Sinks.OpenTelemetry.OtlpProtocol.Grpc;  
        })  
        .CreateLogger();  

    builder.Host.UseSerilog(); // Integra Serilog en el pipeline de .NET  

    // Configura OpenTelemetry para Tracing y Logging  
    builder.Services.AddOpenTelemetry()  
        .WithLogging(logging =>  
        {  
            logging.AddSerilogLogger();  
            logging.AddConsoleExporter();  
        })  
        .WithTracing(tracing =>  
        {  
            tracing.AddAspNetCoreInstrumentation()  
                .AddConsoleExporter();  
        });  

    var app = builder.Build();  
    app.UseHttpsRedirection();  
    app.MapControllers();  
    app.Run();  
    ```

* Configura un exportador para enviar los datos de telemetr√≠a a un backend de observabilidad.

    ```csharp
    using Microsoft.AspNetCore.Mvc;  
    using Serilog;  

    [ApiController]  
    [Route("[controller]")]  
    public class WeatherController : ControllerBase  
    {  
        [HttpGet]  
        public IActionResult GetWeather()  
        {  
            // Log estructurado con Serilog  
            Log.Information("Iniciando consulta del clima | TraceId: {TraceId}", HttpContext.TraceIdentifier);  

            // Simular l√≥gica de negocio  
            var weather = new { Temperature = 25, Condition = "Sunny" };  

            return Ok(weather);  
        }  
    }  
    ```

* Visualiza y analiza los datos de telemetr√≠a en tu backend de observabilidad. Ver√°s en la consola.
    
    Trazas de OpenTelemetry:
    ```json
    {  
    "TraceId": "d798f3e0e4b64e1a9e8622a7c1a1a1a1",  
    "SpanId": "7a1b3c5d9e7f1a2b",  
    "Name": "GET /weather",  
    "Attributes": { "http.method": "GET", "http.route": "/weather" }  
    }  
    ```
    Logs de Serilog enriquecidos:
    
    ```json
    {  
    "@t": "2023-10-05T14:30:00Z",  
    "@mt": "Iniciando consulta del clima | TraceId: {TraceId}",  
    "TraceId": "d798f3e0e4b64e1a9e8622a7c1a1a1a1",  
    "SourceContext": "WeatherController"  
    }  
    ```

* ¬øQu√© Logramos? üéâ
    
    * Correlaci√≥n autom√°tica: Los logs de Serilog incluyen el `TraceId` de OpenTelemetry, permitiendo vincular logs con trazas espec√≠ficas.

    * Logs estructurados: Serilog guarda datos como objetos (no solo texto), √∫til para an√°lisis avanzado.

    * Exportaci√≥n flexible: Los datos pueden enviarse a m√∫ltiples backends (Ej: Jaeger para trazas, Elasticsearch para logs).

* Mejoras Recomendadas para Producci√≥n üõ†Ô∏è

    * Usa un exporter real: Reemplaza `AddConsoleExporter()` por `AddOtlpExporter()` para enviar datos a herramientas como Jaeger o Grafana.

    * Filtra logs: Configura niveles de log (Information, Warning, Error) para evitar saturar el sistema.

    * Enriquece los logs: Usa propiedades como `UserId` o `RequestId` con `LogContext.PushProperty()` de Serilog.

### ST4. Buenas Pr√°cticas y Desaf√≠os en Monitoreo y Logging con Telemetr√≠a

**Lo Que Nunca Debe Faltar**

1. Define m√©tricas clave desde el inicio

    * Ejemplo: Monitorea latencia (tiempo de respuesta), tasa de errores (HTTP 500), y uso de recursos (CPU, memoria).

    * Herramientas: Usa Prometheus para m√©tricas y Grafana para visualizaci√≥n.

    * ¬øPor qu√©? Sin m√©tricas claras, no sabr√°s qu√© est√° fallando hasta que sea demasiado tarde.

2. Correlaciona trazas, logs y m√©tricas

    * Ejemplo: Vincula un TraceId de OpenTelemetry con los logs de Serilog para seguir una transacci√≥n completa.

    * ¬øC√≥mo? Usa campos comunes como TraceId, SpanId, o UserId en todos los datos de telemetr√≠a.

3. Logging estructurado, no solo texto

    * Ejemplo: En vez de "Error al procesar pedido", usa:

    ```json
    {  
    "Level": "Error",  
    "Message": "Procesamiento fallido",  
    "OrderId": 123,  
    "Error": "Timeout en conexi√≥n a BD",  
    "TraceId": "d798f3e0e4b64e1a"  
    }  
    ```
    * Beneficio: Facilita b√∫squedas y an√°lisis en herramientas como Elasticsearch.

4. Implementa sampling inteligente

    * Ejemplo: En producci√≥n, recolecta solo el 10% de las trazas para reducir costos, pero captura el 100% de los errores.

    * Herramientas: Configura el Sampler en OpenTelemetry (ej: ParentBasedSampler).

5. Prioriza alertas accionables

    * Mala pr√°ctica: "Alerta: CPU al 90%".

    * Buena pr√°ctica: "Alerta: CPU al 90% en el servicio de pagos durante 5 minutos. Posible cuello de botella en procesamiento de transacciones".

6. Documenta tu estrategia de telemetr√≠a

    * Incluye:

        - Qu√© m√©tricas se recolectan.

        - D√≥nde se almacenan los datos (ej: Jaeger para trazas, Loki para logs).

        - Qui√©n responde a cada tipo de alerta.

#### Desaf√≠os Comunes (y C√≥mo Superarlos)

1. Sobrecarga de datos

    * **Problema**: Demasiadas m√©tricas o logs saturan el sistema y encarecen el almacenamiento.

    * **Soluci√≥n**:

        - Filtra datos irrelevantes (ej: excluye logs de salud de Kubernetes).

        - Usa agregaciones para m√©tricas (ej: promedio de latencia en vez de cada solicitud).

2. Complejidad en sistemas distribuidos

    * **Problema**: En microservicios, una transacci√≥n cruza 10 servicios. ¬øC√≥mo rastrear el error?

    * **Soluci√≥n**:

        - OpenTelemetry con trazas distribuidas (cada servicio propaga el TraceId).

        - Usa un Service Mesh (como Istio) para automatizar la recolecci√≥n.

3. Costos de almacenamiento

    * **Problema**: Guardar todos los logs y trazas en la nube puede costar miles de d√≥lares.

    * **Soluci√≥n**:

        - Retenci√≥n por niveles: Guarda datos cr√≠ticos en caliente (7 d√≠as) y el resto en fr√≠o (S3, 30 d√≠as).

        - Usa herramientas open-source autoalojadas (ej: VictoriaMetrics para m√©tricas).

4. Ruido en las alertas

    * **Problema**: Alertas que se disparan constantemente por falsos positivos (equipo las ignora).

    * **Soluci√≥n**:

        - Aplica reglas de alertas basadas en ventanas (ej: 5 fallos en 10 minutos).

        - Usa machine learning para detectar anomal√≠as (ej: Dynatrace, New Relic).

5. Privacidad y compliance

    * **Problema**: Logs que incluyen datos sensibles (tarjetas de cr√©dito, emails).

    * **Soluci√≥n**:

        - Enmascara campos cr√≠ticos con herramientas como el RedactionProcessor de OpenTelemetry.

        - Define pol√≠ticas de retenci√≥n que cumplan GDPR/HIPAA.

6. Integraci√≥n de herramientas dispares

    * **Problema**: Trazas en Jaeger, logs en Elasticsearch, m√©tricas en Prometheus.

    * **Soluci√≥n**:

        - Usa un observability backend unificado como Grafana Tempo+Mimir+Loki.

        - Est√°ndares como OpenTelemetry para evitar vendor lock-in.

### Conclusi√≥n

**Observabilidad como Cultura**

La telemetr√≠a no es solo tecnolog√≠a, es un cambio de mentalidad:

* Buenas pr√°cticas te ayudan a evitar caos.

* Desaf√≠os son oportunidades para optimizar.

* Herramientas como OpenTelemetry son el puente entre el c√≥digo y la visibilidad.

Recuerda: Un sistema observable no solo se monitorea‚Ä¶ ¬°se entiende!

Cada una de estas herramientas tiene sus fortalezas y se adapta a diferentes escenarios. Mientras que Microsoft.Extensions.Logging ofrece una soluci√≥n integrada y sencilla, Serilog y NLog destacan por su capacidad para generar logs estructurados y altamente configurables. Por otro lado, log4net sigue siendo una opci√≥n confiable para aplicaciones que requieren estabilidad y compatibilidad con sistemas heredados.

El elegir la herramienta adecuada depender√° de los requisitos espec√≠ficos de tu aplicaci√≥n y del entorno en el que se desplegar√°. Estas herramientas no solo facilitan la depuraci√≥n y el an√°lisis de problemas, sino que tambi√©n son esenciales para construir sistemas escalables y mantenibles.

Si deseas profundizar en estos temas, te recomiendo explorar la documentaci√≥n oficial de cada librer√≠a para conocer todas las opciones y configuraciones disponibles. ¬°El logging es una pieza clave para el √©xito de cualquier aplicaci√≥n en producci√≥n!

> [Back to Menu](../../README.md)